#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class dtEncapsulation "dtEncapsulation" (
    doc = "A digital twin encapsulation."
)
{
    string dtDisplayName = "" (
        doc = "The display name of the digital twin."
    )
    token dtTwinType (
        allowedTokens = ["ItemTwin", "SpaceTwin", "SystemTwin"]
        doc = """The type of digital twin.\r
        ItemTwin: A digital twin of a single item.\r
        SpaceTwin: A digital twin of a space.\r
        SystemTwin: A digital twin of a system.\r
        """
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class dtObjectReference "dtObjectReference" (
    doc = "A reference to an asset file."
)
{
    string[] dtArchitectures = ["default"] (
        doc = "The architectures that the asset is compatible with. e.g. [win-ue5.0, linux-ue5.1]"
    )
    asset dtAsset (
        doc = """The path to the asset that contains, at least, the appearance of the object.\r
        It can also contain physics properties (e.g. UAssets and USD Physics Schema)\r
        """
    )
    string dtPreview = "" (
        doc = "The path or URL to the preview of the asset. e.g a thumbnail. Optional"
    )
    string dtScope = "/" (
        doc = "The scope in the hierarchy of the asset. Defaults to the root."
    )
    string dtSHA256 = "" (
        doc = "The SHA256 hash of the asset. Optional"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class dtScope "dtScope" (
    doc = """An object scope within a dtObjectReference.\r
    Can only contain dtPhysics objects.\r
    """
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class dtPhysics "dtPhysics" (
    doc = """This is the scope for physics-related properties of a specific object.\r
    Can only be contained within a dtScope or a dtObjectReference.\r
    When contained within a dtObjectReference, the physics definition is applied to\r
    the object referenced by the dtScope property.\r
    When contained within a dtScope, the physics definition is applied to the object\r
    referenced by the name of the dtScope.\r
\r
    If the object to which the physics definition is applied is not a leaf in the hierarchy,\r
    the physics definition is applied to the object and all of its descendants.\r
    """
)
{
    point3d dtCenterOfMass = (0, 0, 0) (
        doc = """Center of mass in the prim's local space.\r
        Ignored for Kinematic and Static Twins.\r
        Units: distance."""
    )
    rel dtCollisionShape (
        doc = """\r
        A relationship to a dtCollisionShape scope that defines the collision\r
        bounds for this object.\r
        """
    )
    double dtDensity = 0 (
        doc = """If non-zero, specifies the density of the object.\r
        In the context of rigid body physics, density indirectly results in\r
        setting mass via (mass = density x volume of the object). How the\r
        volume is computed is up to implementation of the physics system.\r
        It is generally computed from the collision approximation rather than\r
        the graphical mesh. In the case where both density and mass are\r
        specified for the same object, mass has precedence over density.\r
        Unlike mass, child's prim's density overrides parent prim's density\r
        as it is accumulative. Note if density is 0.0 it is ignored.\r
        Ignored for Kinematic and Static objects.\r
        Units: mass/distance/distance/distance."""
    )
    double dtDynamicFriction = 0 (
        doc = "Dynamic Friction coefficient. Unitless."
    )
    double dtMass = 0 (
        doc = """If non-zero, directly specifies the mass of the object.\r
        Note that any child prim can also have a mass when they apply massAPI.\r
        In this case, the precedence rule is 'parent mass overrides the\r
        child's'. This may come as counter-intuitive, but mass is a computed\r
        quantity and in general not accumulative. For example, if a parent\r
        has mass of 10, and one of two children has mass of 20, allowing\r
        child's mass to override its parent results in a mass of -10 for the\r
        other child. Note if mass is 0.0 it is ignored.\r
        Ignored for Kinematic and Static objects.\r
        Units: mass.\r
        """
    )
    token dtPhysicsType (
        allowedTokens = ["Static", "Dynamic", "Kinematic"]
        doc = """The type of physics to apply to the object.\r
        Static: The object is static and does not move.\r
        Dynamic: The object is dynamic and moves according to the physics simulation.\r
        Kinematic: The object will not be affected by physics, but it can move.\r
        """
    )
    double dtRestitution = 0 (
        doc = "Restitution coefficient. Unitless."
    )
    double3 dtRotationalInertia = (0, 0, 0) (
        doc = """If non-zero, specifies rotational inertia tensor along the\r
        principal axes. Note if diagonalInertial is (0.0, 0.0, 0.0) it is\r
        ignored. Ignored for Kinematic and Static objects.\r
        Units: mass*distance*distance."""
    )
    double dtStaticFriction = 0 (
        doc = "Static Friction coefficient. Unitless."
    )
}

class dtCollisionShape "dtCollisionShape" (
    doc = """This scope defines the collision bounds for a dtPhysics object.\r
    dtCollisionShapes can only contain Gprims and/or implement one (and only one)\r
    of the Approximation schemas.\r
\r
    The only accepted Gprims are Cube, Sphere, Capsule and Mesh.\r
    The only accepted Approximation are dtSphereApproximation, dtBoxApproximation,\r
    dtHollowBoxApproximation, dtCapsuleApproximation and dtConvexHullApproximation.\r
    """
)
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "invisible" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "dtSphereApproximationAPI" (
    doc = "This scope defines a sphere approximation for a dtCollisionShape."
)
{
    double dtPadding = 0 (
        doc = "Padding of radius of the sphere approximation"
    )
}

class "dtBoxApproximationAPI" (
    doc = "This scope defines a box approximation for a dtCollisionShape."
)
{
    double3 dtPadding = (0, 0, 0) (
        doc = "Padding of the box approximation."
    )
}

class "dtHollowBoxApproximationAPI" (
    doc = "This scope defines a hollow box approximation for a dtCollisionShape."
)
{
    double3 dtPadding = (0, 0, 0) (
        doc = "Padding of the box approximation."
    )
    double dtWallThickness = 0 (
        doc = "Thickness of the walls of the hollow box approximation."
    )
}

class "dtCapsuleApproximationAPI" (
    doc = "This scope defines a capsule approximation for a dtCollisionShape."
)
{
    token dtAxis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        doc = "Axis of the capsule approximation."
    )
    double dtHeightPadding = 0 (
        doc = "Padding of the height of capsule approximation."
    )
    double dtRadiusPadding = 0 (
        doc = "Padding of the radius of capsule approximation."
    )
}

class "dtConvexHullApproximationAPI" (
    doc = "This scope defines a convex hull approximation for a dtCollisionShape."
)
{
    int dtMaxHulls = 4 (
        doc = "Maximum number of hulls"
    )
    int dtMaxVertices = 16 (
        doc = "Maximum number of vertices"
    )
    int dtResolution = 100000 (
        doc = "Convex hull resolution"
    )
}

